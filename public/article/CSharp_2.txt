<div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><h3 _ngcontent-alg-c2="" class="fw-bold" style="box-sizing: border-box; margin-top: 0px; margin-bottom: 0.5rem; line-height: 1.2; font-family: system-ui, -apple-system, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, &quot;Noto Sans&quot;, &quot;Liberation Sans&quot;, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; background-color: rgb(249, 250, 251);"><div style="color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-family: Roboto, sans-serif; font-weight: 400; background-color: rgb(255, 255, 255);"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q011. Can you achieve method overloading by inheritance? How?</span></div><div style="color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-family: Roboto, sans-serif; font-weight: 400; background-color: rgb(255, 255, 255);"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-family: Roboto, sans-serif; background-color: rgb(255, 255, 255);"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="font-weight: 400; color: black; font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Yes, Method Overloading is possible in inheritance as well.&nbsp;A method that is defined in a class can be overloaded under its child class if we overload a method in this process we call it inheritance-based overloading.</span></div><div style="font-weight: 400; color: black; font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">In VB.Net when you are overloading a method of the base class in the derived class, then you must use the keyword “Overloads”. But in C# there is no need to use any keyword while overloading a method either in the same class or in the derived class.</div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">When the compiler is looking for an overloaded instance method, it considers the compile-time class of the "target" call and looks at methods declared there. If it can't find anything suitable match, it then looks at the parent class and at last the grandparent class.</div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">So if there are two matching methods at different levels of the hierarchy, the "deeper" one will be chosen first, even if it is not a "better function member" for the call.</div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">012. Can you overload the main() method in C#? Overriding the main method is possible or not?</span></div><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">The Main() method is the entry point in a C# program from where the execution starts. It is always a static method. Overloading of the Main() method is allowed. But in that case, only one Main() method is considered as one entry point to start the execution of the program.&nbsp;</div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">But remember the method modifier and access modifier cannot be used to overload a method. Please read the method overloading rules&nbsp;<a href="https://www.techpointfunda.com/2021/11/method-overloading-and-overloading.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>for more details.</div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">The Main() method cannot be overridden because it is the static method and a static method cannot be virtual or abstract.&nbsp; Please read more about the method overriding&nbsp;<a href="https://www.techpointfunda.com/2020/11/virtual-method-and-method-override-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.</div><div style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;"><br></span></div><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q013. Can you achieve method overriding without inheritance, how?</span></div><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;">No, If a method cannot be inherited, it cannot be overridden also. Please read more about the method overriding&nbsp;<a href="https://www.techpointfunda.com/2020/11/virtual-method-and-method-override-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.</span></div><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;">But shadowing (hiding) is possible without inheritance. Please read more about shadowing&nbsp;<a href="https://www.techpointfunda.com/2020/11/shadowing-or-method-hiding-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.</span></div><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br></span></div><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="font-weight: 400; color: rgb(46, 46, 46); font-size: 14px; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q014. What is the difference between Method Overriding and Method Hiding?</span></div><div style=""><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><ol style="font-weight: 400; color: rgb(68, 68, 68); font-size: medium; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px 0px 0px 15px; line-height: 1.5;"><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">Shadowing is used to protect against subsequent base class modification, while overriding does polymorphism by defining a different implementation.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">Shadowing can redefine the entire signature, on the other hand, overriding can redefine only the implementation of a method, not the signature.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">For overriding, the base class member must be declared as virtual while it is not mandatory for shadowing.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">In shadowing, we can change the access modifier, while we cannot change the access modifier in overriding.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">You cannot override a method with a property (or variable), or vice-versa, but you can shadow.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">The "override" keyword cannot be used with the "virtual" modifier while the "new" keyword can be used with the "virtual" modifier.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">In the case of shadowing, the base class cannot access the shadowed members in the derived class, while in the case of overriding the base class can access the overridden members in the derived class.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">There is no control of a base class on shadowing i.e. a base class cannot enforce or prohibit shadowing, but it has control over overriding.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">In overriding, a base class reference variable pointing to a child class object will invoke the overridden member in the derived class, not the base class. While in the case of shadowing it will invoke the base class members, not the derived class shadowed members.</li></ol><div style="font-weight: 400;"><font color="#444444" size="3"><br></font></div><div style=""><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q015. We have two methods, one is returning IEnumerable results and the second one is void. Is it an example of Static Polymorphism?</span></div><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;">No. Two methods can't be overloaded only based on the return type. Please read more&nbsp;<a href="https://www.techpointfunda.com/2021/11/method-overloading-and-overloading.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>about return type and overloading rules.</span></div><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br></span></div><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q016. What is Constructor Overloading in C#? Can you overload a static constructor in C#?</span></div><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">A constructor is nothing but a method without any return type which has the same name as the class or struct name. Constructors are called automatically when we create the object of the class.&nbsp;</div><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Constructor overloading is not much different than method overloading. In the case of method overloading we have multiple methods with the same name but different signatures, whereas in Constructor overloading we have multiple constructors with different signatures.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">But the only difference is that Constructor doesn’t have a return type in C#. Constructor overloading is used to pass different parameters based on requirements. Please read the Constructor and Constructor Overloading article&nbsp;<a href="https://www.techpointfunda.com/2020/12/constructors-in-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Static constructors cannot be overloaded because static constructors are always parameterless. Please read the Static Class and Static Constructor article&nbsp;<a href="https://www.techpointfunda.com/2020/09/static-class-constructor-method-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>. Please watch the Static Constructor video here.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q017. What is the difference between a virtual method and an abstract method?</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><ol style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px 0px 0px 15px; line-height: 1.5;"><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">An abstract method cannot contain body definition while a virtual method must have a body definition.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">Overriding all the abstract methods in the inheriting concrete class is mandatory while overriding the virtual methods is optional.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">The "abstract" modifier can be used while overriding the abstract method but the "virtual" modifier cannot be used while overriding a virtual method.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">An abstract method can only be declared in an abstract class while a virtual method can be defined in a non-abstract class as well.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">A virtual method can be overridden to abstract for achieving re-abstraction but an abstract method cannot be overridden to virtual.</li></ol><div><br></div><div><br></div><div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q018. What is the difference between inheritance and composition? Why Composition is immune to Fragile Base Class Problem?</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Both Inheritance and Composition are used to access the existing methods and properties of other classes. Inheritance derives one class from another, composition defines a class as the sum of its parts.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Classes and objects created through inheritance are tightly coupled because changing the parent or superclass in an inheritance relationship risks breaking your code. Classes and objects created through composition are loosely coupled, meaning that you can more easily change the component parts without breaking your code. Loosely coupled code offers more flexibility.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Class inheritance is a technique that allows us to create new classes from existing classes. Inheritance contributes a lot to software reuse but also cause tight coupling and fragile base class problem.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Another technique for software reuse is composition. By composition, in our classes under development, we explicitly declare data members as objects of some existing classes.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Composition is generally used when we want the feature of some existing classes inside our new classes, but not their interface i.e we want to use their functionalities to implement features of our new classes.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Composition is immune to Fragile Base Class Problem because it does not use inheritance. The main reason to use composition is that it allows you to reuse code without modeling an is-a association as you do by using inheritance.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Association is a relation between two separate classes which establishes through their Objects. In Object-Oriented programming, an Object communicates to other Objects to use functionality and services provided by that object. Composition and Aggregation are the two forms of association.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q019. How can you achieve composition with the abstract classes?&nbsp;</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">We can also achieve composition with the abstract class as well. We know that we cannot create the object of an abstract class, but we can create a reference variable of an abstract class.&nbsp;</span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">But for that, there should be at least one concrete class that has implemented the abstract class.&nbsp;</span></span></div><div><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br></span></span></div><div><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br></span></span></div><div><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q020. What happens if the inherited interfaces have conflicting method names? or What is explicit interface implementation?</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;">If two interfaces have methods with the same name, we have to implement them explicitly by providing the full name i.e InterfaceName.MethodName.&nbsp;</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;">In this case, we also need to use the full name for calling that method. If you are not implementing them explicitly, the same method will be called for all the interfaces.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px; text-align: right;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><b style="outline: 0px; transition: all 0.3s ease 0s; color: red; font-size: x-large;">To Be Continued Part-03...</b></span></div></span></span></div></div></div></div></span></div></div></div></span></div></div></div><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">A constructor can also be overloaded just like methods by using different signatures. A class or struct may have multiple constructors that take different arguments.</div><div style="font-weight: 400; outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">This content is copy from&nbsp;<b><u><a href="https://www.techpointfunda.com" class="text-decoration-none" target="_blank">https://www.techpointfunda.com</a></u></b></div></span></div></span></div></div></span></div></span></div></div></span></div></div></span></div></span></div></h3></div>