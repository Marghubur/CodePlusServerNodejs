<p id="d8b2" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Building SPAs, we sometimes come across the need to display data using the technique of infinite scrolling — i.e., continuously loading data as the user scrolls down the page.</p><p id="d356" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Ever since the&nbsp;<a class="af oq" href="https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent;">Intersection Observer API</a>&nbsp;was added to browsers, building a reusable infinite scroll component has never been easier. Let’s learn how we can create such a component using this API.</p><p id="d376" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Note that we’re not going to dive into the Intersection Observer API, so if you’re not familiar with it, I recommend reading&nbsp;<a class="af oq" href="https://www.smashingmagazine.com/2018/01/deferring-lazy-loading-intersection-observer-api/" rel="noopener ugc nofollow" target="_blank" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent;">this</a>&nbsp;article beforehand.</p><h1 id="d698" class="or os gr be ot ou ov ow ox oy oz pa pb pc pd pe pf pg ph pi pj pk pl pm pn po bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 1.95em 0px -0.28em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); line-height: 30px; letter-spacing: -0.016em; font-size: 24px; background-color: rgb(255, 255, 255);">Creating the Component</h1><p id="5cba" class="pw-post-body-paragraph nt nu gr be b nv pp nx ny nz pq ob oc od pr of og oh ps oj ok ol pt on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 0.86em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">The main concept is to place an&nbsp;<span class="be pu" style="box-sizing: inherit;">observable element</span>&nbsp;at the end of a list of displayed items, in order to add more data when the user reaches the bottom of that list.</p><p id="5cba" class="pw-post-body-paragraph nt nu gr be b nv pp nx ny nz pq ob oc od pr of og oh ps oj ok ol pt on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 0.86em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);"><br></p><pre style="overflow-wrap: break-word;">@Component({
  selector: 'infinite-scroll',
  template: `&lt;ng-content&gt;&lt;/ng-content&gt;&lt;div #anchor&gt;&lt;/div&gt;`,
})
export class InfiniteScrollComponent implements OnInit, OnDestroy {
  @Input() options = {};
  @Output() scrolled = new EventEmitter();
  @ViewChild('anchor') anchor: ElementRef&lt;HTMLElement&gt;;

  private observer: IntersectionObserver;

  constructor(private host: ElementRef) { }

  get element() {
    return this.host.nativeElement;
  }
}</pre><p id="be45" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">We want to make as it flexible as possible, so we let our consumers pass any template they want using&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">ng-content</code>. Below it, we add an anchor element which will serve as the target element that we watch.</p><p id="2c58" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Let’s create the&nbsp;<a class="af oq" href="https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent;">Intersection Observer</a>:</p><pre style="overflow-wrap: break-word;"><br></pre><pre style="overflow-wrap: break-word;">@Component({
  selector: 'infinite-scroll',
  template: `&lt;ng-content&gt;&lt;/ng-content&gt;&lt;div #anchor&gt;&lt;/div&gt;`
})
export class InfiniteScrollComponent implements OnInit, OnDestroy {
  ...
  
  ngOnInit() {
    const options = {
      root: null,
      ...this.options
    };

   this.observer = new IntersectionObserver(([entry]) =&gt; {
      entry.isIntersecting &amp;&amp; this.scrolled.emit();
    }, options);

    this.observer.observe(this.anchor.nativeElement);
  }

}</pre><p id="bd50" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">First, we create a new&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">IntersectionObserver</code>&nbsp;which receives&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">entries</code>&nbsp;as its argument. This function will be called whenever the observed element enters the viewport.</p><p id="cb78" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">We can check the element’s visibility status by looking at the&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">isIntersection</code>&nbsp;property. If&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">isIntersecting</code>&nbsp;is true, the target element has become at least as visible as the threshold that was passed. The default threshold is 0, meaning as soon as even one pixel is visible, the callback will be run.</p><p id="c0f7" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Next, we call the&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">observe()</code>&nbsp;method, passing it the anchor element. This will initiate the observation of this element.</p><h2 id="4cc7" class="qh os gr be ot qi qj dx ox qk ql dz pb od qm qn qo oh qp qq qr ol qs qt qu qv bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 1.72em 0px -0.31em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); line-height: 24px; font-size: 20px; background-color: rgb(255, 255, 255);">🦊 Support Scrollable Containers</h2><p id="1832" class="pw-post-body-paragraph nt nu gr be b nv pp nx ny nz pq ob oc od pr of og oh ps oj ok ol pt on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 0.86em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">The&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">root</code>&nbsp;property indicates the element that is used as the viewport for checking the visibility of the target. When set to&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">null</code>&nbsp;it defaults to the browser viewport.</p><p id="ed1f" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">There are times when we’ll need to have a scrollable container, and then we’d want that container to act as the&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">root</code>&nbsp;element. Let’s support this functionality:</p><pre style="overflow-wrap: break-word;"><br></pre><pre style="overflow-wrap: break-word;">@Component({
  selector: 'infinite-scroll',
  template: `&lt;ng-content&gt;&lt;/ng-content&gt;&lt;div #anchor&gt;&lt;/div&gt;`
})
export class InfiniteScrollComponent implements OnInit, OnDestroy {
  ...

  ngOnInit() {
    const options = {
      root: this.isHostScrollable() ? this.host.nativeElement : null,
      ...this.options
    };

    this.observer = new IntersectionObserver(([entry]) =&gt; {
      entry.isIntersecting &amp;&amp; this.scrolled.emit();
    }, options);

    this.observer.observe(this.anchor.nativeElement);
  }

  private isHostScrollable() {
    const style = window.getComputedStyle(this.element);

    return style.getPropertyValue('overflow') === 'auto' ||
      style.getPropertyValue('overflow-y') === 'scroll';
  }
}</pre><p id="db0c" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">We add a check to see whether the current host element is a scrollable container. If it is, we set it as the&nbsp;<code class="cw qd qe qf qg b" style="box-sizing: inherit; background-color: rgb(242, 242, 242); padding: 2px 4px; font-size: 15px; font-family: source-code-pro, Menlo, Monaco, &quot;Courier New&quot;, Courier, monospace;">root</code>&nbsp;element.</p><p id="c3dd" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Finally, we don’t want memory leaks in our application, so we’ll disconnect the observer when the component destroyed:</p><pre style="overflow-wrap: break-word;">ngOnDestroy() {
  this.observer.disconnect();
}</pre><p id="7435" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">It’s as simple as that.</p><p id="8250" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Let’s see how we use it:</p><pre style="overflow-wrap: break-word;">@Component({
  selector: 'app-tweets',
  template: `
     &lt;infinite-scroll (scrolled)="onScroll()"&gt;
       &lt;app-tweet *ngFor="let tweet of tweets$ | async" [tweet]="tweet"&gt;&lt;/app-tweet&gt;

       &lt;div *ngIf="isLoading$ | async"&gt;
         Fetching tweets...
       &lt;/div&gt;
     &lt;/infinite-scroll&gt;
  `
})
export class TweetsComponent implements OnInit {
  ...
}</pre><p id="1603" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Or with a scrollable container:</p><pre style="overflow-wrap: break-word;"><span style="color: rgb(255, 255, 255); text-wrap: wrap;">@Component({
</span>  selector: 'app-tweets',
  template: `
     &lt;infinite-scroll (scrolled)="onScroll()" style="height: 400px; overflow-y: auto"&gt;
       ...
     &lt;/infinite-scroll&gt;
  `
})
export class TweetsComponent implements OnInit {
  ...
}</pre><h1 id="7249" class="or os gr be ot ou ov ow ox oy oz pa pb pc pd pe pf pg ph pi pj pk pl pm pn po bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 1.95em 0px -0.28em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); line-height: 30px; letter-spacing: -0.016em; font-size: 24px; background-color: rgb(255, 255, 255);">Browser Support</h1><p id="d3e9" class="pw-post-body-paragraph nt nu gr be b nv pp nx ny nz pq ob oc od pr of og oh ps oj ok ol pt on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 0.86em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">The Intersection Observer API works in most major browsers. If you need to support old browsers such as IE, you can load a&nbsp;<a class="af oq" href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill" rel="noopener ugc nofollow" target="_blank" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent;">polyfill</a>&nbsp;or fallback to the scroll event in runtime.</p><h1 id="d57c" class="or os gr be ot ou ov ow ox oy oz pa pb pc pd pe pf pg ph pi pj pk pl pm pn po bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 1.95em 0px -0.28em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); line-height: 30px; letter-spacing: -0.016em; font-size: 24px; background-color: rgb(255, 255, 255);">🚀<span class="al" style="box-sizing: inherit; font-weight: inherit;">&nbsp;Have You Tried Akita Yet?</span></h1><p id="eaab" class="pw-post-body-paragraph nt nu gr be b nv pp nx ny nz pq ob oc od pr of og oh ps oj ok ol pt on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 0.86em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">One of the leading state management libraries, Akita has been used in countless production environments. It’s constantly developing and improving.</p><p id="9f29" class="pw-post-body-paragraph nt nu gr be b nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op gk bj" data-selectable-paragraph="" style="box-sizing: inherit; margin: 2em 0px -0.46em; font-family: sohne, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; color: rgb(36, 36, 36); word-break: break-word; line-height: 32px; letter-spacing: -0.003em; font-size: 20px; background-color: rgb(255, 255, 255);">Whether it’s entities arriving from the server or UI state data, Akita has custom-built stores, powerful tools, and tailor-made plugins, which help you manage the data and negate the need for massive amounts of boilerplate code. We/I highly recommend you try it out.</p>