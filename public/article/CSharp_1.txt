<div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-family: Roboto, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q001. What are the 4 pillars of OOPS?</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-family: Roboto, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-family: Roboto, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><p style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">There are four pillars of any object-oriented programming language:</span></p><p style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></p><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><b style="outline: 0px; transition: all 0.3s ease 0s;">1.&nbsp;Abstraction:</b></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Abstraction is the process of hiding the internal complex details and showing only the minimum required functionality to the external users.&nbsp;Both&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">abstract class and interface</b>&nbsp;are used for data abstraction.&nbsp;It ensures that only the required information is visible to the user and the rest of the information is hidden from the external world.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><b style="outline: 0px; transition: all 0.3s ease 0s;">2.&nbsp;Encapsulation:</b></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Encapsulation is the process of binding the data members (properties or variables) to the methods. It wraps the member functions and data members into a single unit. The encapsulation hides or restricts the internal data member from accessing the other external classes. Therefore it is also known as&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">data hiding</b>.&nbsp;&nbsp;</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Encapsulation is achieved by declaring all the variables in the class as private and using properties in the class to set and get the values of variables.&nbsp;Please watch the&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">variable vs properties&nbsp;</b>video&nbsp;<a href="https://youtu.be/3YfiJc3mSRM" rel="nofollow" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>for more details.</span></div><p style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></p><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><b style="outline: 0px; transition: all 0.3s ease 0s;">3.&nbsp;Inheritance:</b></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Inheritance is a way to access and use the properties and methods of other classes. The original class is known as the&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">base class</b>&nbsp;and the class which inherits the functionality of the base class is the&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">derived class</b>. Inheritance provides&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">code reusability</b>.&nbsp;C# does not support&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">multiple class inheritance</b>&nbsp;due to the&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">diamond problem</b>&nbsp;but&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">multiple interfaces inheritance</b>&nbsp;is allowed.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><b style="outline: 0px; transition: all 0.3s ease 0s;">4.&nbsp;Polymorphism:</b></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">The term "polymorphism" means "having many forms". So in OOPS, it means that an object can have multiple functionalities. There are two types of polymorphism in OOPS.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><b style="outline: 0px; transition: all 0.3s ease 0s;">Static Polymorphism</b>&nbsp;or&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Early Binding</b>&nbsp;involves linking a method with an object during compile time, hence also known as&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Compile Time Binding</b>.&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Method Overloading</b>&nbsp;and&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Operator Overloading</b>&nbsp;are the way to achieve&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Static Polymorphism</b>. Please read the Static Polymorphism article&nbsp;<a href="https://www.techpointfunda.com/2021/10/static-polymorphism-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>for more details</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><b style="outline: 0px; transition: all 0.3s ease 0s;">Dynamic Polymorphism&nbsp;</b>or&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Late Binding</b>&nbsp;involves linking a method with an object during run time, hence also known as&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Run Time-Binding</b>.&nbsp;</span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><b style="outline: 0px; transition: all 0.3s ease 0s;">Method Overriding</b>&nbsp;is a way to achieve Dynamic Polymorphism. Please read the&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Dynamic Polymorphism</b>&nbsp;article&nbsp;<a href="https://www.techpointfunda.com/2020/11/virtual-method-and-method-override-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>for more details.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q002. What is the difference between Abstraction and Encapsulation?</span></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Both seem very similar but totally different in concept and implementation. In OOPS abstraction hides the code complexity while encapsulation hides the internal working from the outside world.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Abstraction is a way to only show the essential data to the user. It solves an issue at the design level. For abstraction,&nbsp;<a href="https://www.techpointfunda.com/2020/10/abstract-class-abstract-method-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">abstract classes</a>&nbsp;and&nbsp;<a href="https://www.techpointfunda.com/2020/09/interface-modifier-csharp-8.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">interfaces&nbsp;</a>are used.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">On the other hand, encapsulation hides the code and data into a single entity or unit so that the data can be protected from the outside world. It is an implementation-level process. It is achieved by different access modifiers like private, public, protected. The getters and setters methods of properties are used to hide the data.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Please read more about the abstract class&nbsp;<a href="https://www.techpointfunda.com/2020/10/abstract-class-abstract-method-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>&nbsp;and abstract class vs interface&nbsp;<a href="https://www.techpointfunda.com/2020/09/abstract-class-vs-interface-csharp8.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q003. What is the difference between Class and Structure in C#?</span></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><ol style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px 0px 0px 15px; line-height: 1.5; color: black;"><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">All the structs are value types while classes are reference types.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Structs cannot have destructors, but classes can have destructors.&nbsp;</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Structs cannot have an explicit default constructor while a class can have a default constructor.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Structs do not support inheritance while classes support inheritance.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">Instance field declarations for a struct are not permitted to include variable initializers while a class can initialize the field members.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">In C# user can copy one structure object into another one using the assignment operator (=) but a class cannot be.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">A structure cannot have the abstract, virtual, or sealed members while a class can have.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">A structure cannot have a sealed method but a class can have sealed methods.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);">A structure can only override the Object class virtual methods while a class can override any base class virtual method and abstract method.</span></li></ol><p style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-family: inherit;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></p><p style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-family: inherit;">Please read the complete&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">C# Structure</b>&nbsp;article&nbsp;<a href="https://www.techpointfunda.com/2021/01/Structure-Or-Struct-CSharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.</span></p></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: black; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q004. What are the different Access Modifiers in C#?</span></span></span></div></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Access modifiers specify the accessibility of an object and all of its members. All the C# types (class, interface, structure, etc) have access modifiers implemented, even if they are not stated i.e default access modifiers.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">There are six access modifiers in C#, four core types of access modifiers: private, public, protected, internal, and two combined access types: protected-internal and private-protected.&nbsp;</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">All the access modifiers are valid for all types and members in all contexts. In some cases, the accessibility of a type member is constrained by the accessibility of its containing type as well.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">1. Private:</b>&nbsp;A private type or member can be accessed only by code in the same class or struct. Objects that are specified with private access modifiers are accessible only inside that class, interface, or structure. So nobody can access them outside the declaring class they are created.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">2. Public:</b>&nbsp;A public type or member can be accessed by any other code in the same assembly or another assembly that references it. The accessibility level of public members of a type is controlled by the accessibility level of the type itself. Objects that specified public access modifiers are accessible from everywhere in the project and assemblies. So there are no accessibility restrictions at all.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">3. Protected:</b>&nbsp;A protected type or member can be accessed only by code in the same class, or in a class that is derived from that class. Objects that specified protected access modifiers are accessible within the declaring class and inheriting class only. So the protected keyword implies that the object is accessible inside the class and in all classes that derive from that class.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">4. Internal:&nbsp;</b>A internal type or member can be accessed by any code in the same assembly, but not from another assembly. In other words, internal types or members can be accessed from code that is part of the same compilation. The internal keyword specifies that the object is accessible only inside its own assembly but not in other assemblies.&nbsp;</div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">5. Protected Internal:</b>&nbsp;A protected internal type or member can be accessed by any code in the assembly in which it's declared, or from within a derived class in another assembly. The protected internal access modifier is a combination of protected and internal. Therefore it has both features. So you can access a protected internal member only in the same assembly or in a derived class of other assemblies or projects as well.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">6. Private Protected:</b>&nbsp;A private protected type or member can be accessed by types derived from the containing classes that are declared within its containing assembly. The private protected access modifier is a combination of private and protected keywords. Therefore it also has both features. So you can access private protected members-only inside the declaring class or in the derived class, but only in the same assembly(project). If you try to access it from another assembly, you will get an error.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">Default Accessibility:&nbsp;</b></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></b></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68);"><ol style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px 0px 0px 15px; line-height: 1.5;"><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">All the Classes, records, and structs declared directly within a namespace(non-nested) can be either public or internal. The internal is the default if no access modifier is specified.&nbsp;</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Class and struct members, including nested classes and structs, have private access by default.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">All private nested types aren't accessible from outside the containing type.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Derived classes can't have greater accessibility than their base types. So you can't declare a public class B that derives from an internal class A.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Struct members can't be declared as protected, protected internal, or private protected because structs don't support inheritance.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Normally, the accessibility of a member isn't greater than the accessibility of the type that contains it. However, a public member of an internal class might be accessible from outside the assembly if the member implements interface methods or override virtual methods that are defined in a public base class.</span></li><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">User-defined operators must always be declared as public and static.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Destructors can't have any accessibility modifiers.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">The type of any member field, property, or event must be at least as accessible as the member itself. Similarly, the return type and the parameter types of any method, indexer, or delegate must be at least as accessible as the member itself.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Interfaces declared directly within a namespace can be public or internal and, just like classes and structs, interfaces default to internal access.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Interface members are public by default because the purpose of an interface is to enable other types to access a class or struct. Interface member declarations may also include any access modifier after C#8.&nbsp;</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Enumeration members are always public, and no access modifiers can be applied.</span></li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;">Since delegates behave like classes and structs. So by default, they have internal access when declared directly within a namespace, and private access when nested.</span></li></ol></div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: large;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q005. What is Polymorphism in C#? What are the different types of Polymorphism?</span></div></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.&nbsp; The term "polymorphism" means "having many forms". So in OOPS, it means that an object can have multiple functionalities.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">There are two types of polymorphism in OOPS.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">1. Static Polymorphism:</b></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></b></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Static Polymorphism or Early Binding involves linking a method with an object during compile time, hence also known as Compile Time Binding. Method Overloading and Operator Overloading are the way to achieve Static Polymorphism.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Please read the Static Polymorphism article&nbsp;<a href="https://www.techpointfunda.com/2021/10/static-polymorphism-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>for more details. You can also read the Static Polymorphism Rules&nbsp;<a href="https://www.techpointfunda.com/2021/11/method-overloadings-part3.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">2. Dynamic Polymorphism:</b></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Dynamic Polymorphism or Late Binding involves linking a method with an object during run time, hence also known as Run Time-Binding. Method Overriding is a way to achieve Dynamic Polymorphism.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays. When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q006. What are the different ways to implement Polymorphism in C#?</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">Static Polymorphism</b>&nbsp;can be achieved by overloading. If we create two or more members having the same name but different signatures, it is known as member overloading.</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Following are the different ways to implement static polymorphism:&nbsp;</span></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: large;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; font-size: medium;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><ul style="outline: 0px; transition: all 0.3s ease 0s; margin: 0.5em 0px; padding: 0px 2.5em; line-height: 1.5;"><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style: none; line-height: 1.5;">Method Overloading</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style: none; line-height: 1.5;">Operator Overloading</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style: none; line-height: 1.5;">Constructor Overloading</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style: none; line-height: 1.5;">Indexer Overloading</li></ul></div></span></span></div></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Please read about the Static Polymorphism implementation&nbsp;<a href="https://www.techpointfunda.com/2021/10/static-polymorphism-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>for more details.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">Dynamic Polymorphism</b>&nbsp;can be achieved by method overriding. Base classes may define and implement virtual methods, and derived classes can override them, which means they provide their own definition and implementation.&nbsp;</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">At run-time, when the client code calls the method, the CLR looks up the run-time type of the object and invokes that override of the virtual method. In your source code, you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Please read the Dynamic Polymorphism implementation article&nbsp;<a href="https://www.techpointfunda.com/2020/11/virtual-method-and-method-override-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.&nbsp;</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q007. What is the difference between Early Binding and Late Binding in C#? or What is the difference between Compile Time Polymorphism and Run-Time Polymorphism in C#?</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">In&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Early Binding</b>, the compiler knows about what kind of object it is, what are all the methods and properties it contains. As soon as you declared the object, .NET Intellisense will populate its methods and properties.&nbsp; If a method or property does not exist or has data type problems then the compiler automatically throws an exception during compile time.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">On the other hand in&nbsp;<b style="outline: 0px; transition: all 0.3s ease 0s;">Late Binding</b>&nbsp;compiler does not know what kind of object it is, what are all the methods and properties it contains. Everything will be known and loaded at the run time. When an object is dynamic or not known which will only bind during runtime is called Late binding.&nbsp;</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Please read about the Early Binding&nbsp;<a href="https://www.techpointfunda.com/2021/10/static-polymorphism-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>&nbsp;and Late Binding&nbsp;<a href="https://www.techpointfunda.com/2020/11/virtual-method-and-method-override-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>for more details.</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><br style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q008. What is Shadowing in C#? or&nbsp; What is the Method Hiding in C#? How can you achieve that?</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><b style="outline: 0px; transition: all 0.3s ease 0s;">Shadowing&nbsp;</b>is also known as hiding. In C# you can hide the methods of the base class from the derived class, this concept is known as Method Hiding or Method Shadowing. The term "Shadowing" is normally used in VB.Net which is known as "Hiding" in C#.Net.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">When you say "shadow" you're usually talking about scope while when you say "hiding" you're usually talking about inheritance.</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">When two-member use the same name, one of them can hide, or shadow, the other one. By shadowing the child class can create its own version of the base class method or property.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">A method of the base class is available to the child class with a new definition or implementation without using the override keyword.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">The "<b style="outline: 0px; transition: all 0.3s ease 0s;">new</b>" keyword is used to perform shadowing, but if it is not used the compiler generates a warning. The compiler hides the method or property of the base class.&nbsp;</div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;">Please read the Shadowing article&nbsp;<a href="https://www.techpointfunda.com/2020/11/shadowing-or-method-hiding-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here&nbsp;</a>for more details.</div></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q009. What is the abstract method? How an abstract method is different from the virtual method?</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;">A method without body definition and having an "abstract" modifier is known as an abstract method. The keyword "abstract" can only be used just before the return type of the method. Before C# 8 only abstract classes can have abstract methods, but with the introduction of C# 8 interfaces can also have abstract members.&nbsp;</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;">The abstract modifier indicates that the type being modified has a missing or incomplete implementation. So the inheriting class must have to implement all the abstract members with the "override"&nbsp; keyword unless the inheriting class is also an abstract class because all the abstract methods are virtual implicitly.</span></div><div><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br></span></div><div><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><b style="outline: 0px; transition: all 0.3s ease 0s;">Abstract Method vs Virtual Method:</b></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><b style="outline: 0px; transition: all 0.3s ease 0s;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></b></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><ol style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px 0px 0px 15px; line-height: 1.5;"><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">An abstract method cannot contain body definition while a virtual method must have a body definition.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">Overriding all the abstract methods in the inheriting concrete class is mandatory while overriding the virtual methods is optional.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">The "abstract" modifier can be used while overriding the abstract method but the "virtual" modifier cannot be used while overriding a virtual method.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">An abstract method can only be declared in an abstract class while a virtual method can be defined in a non-abstract class as well.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">A virtual method can be overridden to abstract for achieving re-abstraction but an abstract method cannot be overridden to virtual.</li></ol></div></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;">Please read the Abstract Method complete article&nbsp;<a href="https://www.techpointfunda.com/2020/10/abstract-class-abstract-method-csharp.html" target="_blank" style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; text-decoration-line: none; color: rgb(0, 136, 255);">here</a>.&nbsp;</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><br style="outline: 0px; transition: all 0.3s ease 0s; color: rgb(46, 46, 46); font-size: 14px;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(204, 0, 0); font-size: large;">Q010. What is the difference between Overloading and Overriding in C#?</span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><br style="outline: 0px; transition: all 0.3s ease 0s;"></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-size: medium;"><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px;"><ol style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px 0px 0px 15px; line-height: 1.5;"><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">Method Overloading is static polymorphism while Method Overriding is dynamic polymorphism. So Method Overloading executes at compile-time while Method Overriding executes at run-time.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">Method Overloading is generally defined in the same class while Method Overriding only is used in inheritance.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">For Method Overriding the base class method must be virtual (abstract in abstract class) while it is not required in the case of Method Overloading.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">In Method Overriding you can not change the method signature in the derived class while Method Overloading is only possible with different method signatures.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">Method Overriding requires forcefully rewriting the method definition with the same signature in the derived class while Method Overloading is more flexible by allowing different signatures for different overloading methods.</li><li style="outline: 0px; transition: all 0.3s ease 0s; margin: 5px 0px; padding: 0px; list-style-type: decimal; line-height: 1.5;">The Overriding Method is not considered as an overloaded member of the derived class, while other methods with the same name and different signatures are considered as the overloaded methods.</li></ol><div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px; text-align: right;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: red; font-size: large;"><b style="outline: 0px; transition: all 0.3s ease 0s;"><br></b></span></div><div style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: rgb(46, 46, 46); font-size: 14px; text-align: right;"><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: red; font-size: large;"><b style="outline: 0px; transition: all 0.3s ease 0s;">To Be Continued Part-02...</b></span></div></div><div><span style="outline: 0px; transition: all 0.3s ease 0s; margin: 0px; padding: 0px; color: red; font-size: large;"><b style="outline: 0px; transition: all 0.3s ease 0s;"><br></b></span></div></div></span></div></span></div></div></span></div></div></span></div></div></div></span></span></div></span></div></span></div></span></div>